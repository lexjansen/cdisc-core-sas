{
  "$defs": {
    "Boolean": {
      "oneOf": [
        {
          "additionalProperties": false,
          "properties": {
            "all": {
              "$ref": "#/$defs/CheckItems"
            }
          },
          "required": [
            "all"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "any": {
              "$ref": "#/$defs/CheckItems"
            }
          },
          "required": [
            "any"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "not": {
              "$ref": "#/$defs/CheckItem"
            }
          },
          "required": [
            "not"
          ],
          "type": "object"
        }
      ]
    },
    "CheckItem": {
      "anyOf": [
        {
          "$ref": "#/$defs/Boolean"
        },
        {
          "$ref": "#/$defs/Operator.json"
        }
      ]
    },
    "CheckItems": {
      "items": {
        "$ref": "#/$defs/CheckItem"
      },
      "type": "array"
    },
    "Classes": {
      "items": {
        "enum": [
          "ALL",
          "EVENTS",
          "FINDINGS",
          "FINDINGS ABOUT",
          "INTERVENTIONS",
          "RELATIONSHIP",
          "SPECIAL PURPOSE",
          "STUDY REFERENCE",
          "TRIAL DESIGN"
        ],
        "type": "string"
      },
      "type": "array"
    },
    "Dataset": {
      "anyOf": [
        {
          "enum": [
            "ALL",
            "AP--",
            "APRELSUB",
            "POOLDEF",
            "RELREC",
            "RELREF",
            "RELSPEC",
            "RELSUB",
            "SUPP--"
          ],
          "type": "string"
        },
        {
          "pattern": "^([A-Z]{2}|[A-Z]{4}|SUPP[A-Z]{2}|SUPP[A-Z]{4}|SQAP[A-Z]{4})$",
          "type": "string"
        }
      ]
    },
    "Datasets": {
      "items": {
        "$ref": "#/$defs/Dataset"
      },
      "type": "array"
    },
    "DataStructure": {
      "enum": [
        "ADAM OTHER",
        "ALL",
        "BASIC DATA STRUCTURE",
        "DEVICE LEVEL ANALYSIS DATASET",
        "MEDICAL DEVICE BASIC DATA STRUCTURE",
        "MEDICAL DEVICE OCCURRENCE DATA STRUCTURE",
        "OCCURRENCE DATA STRUCTURE",
        "SUBJECT LEVEL ANALYSIS DATASET"
      ],
      "type": "string"
    },
    "DataStructures": {
      "items": {
        "$ref": "#/$defs/DataStructure"
      },
      "type": "array"
    },
    "Domains": {
      "items": {
        "$ref": "#/$defs/Dataset"
      },
      "type": "array"
    },
    "DomainStructure": {
      "additionalProperties": false,
      "properties": {
        "Exclude": {
          "$ref": "#/$defs/Domains"
        },
        "Include": {
          "$ref": "#/$defs/Domains"
        },
        "include_split_datasets": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "JoinType": {
      "enum": [
        "inner",
        "left"
      ],
      "type": "string"
    },
    "LeftRightKeys": {
      "additionalProperties": false,
      "properties": {
        "Left": {
          "$ref": "#/$defs/VariableName"
        },
        "Right": {
          "$ref": "#/$defs/VariableName"
        }
      },
      "required": [
        "Left",
        "Right"
      ],
      "type": "object"
    },
    "PascalCases": {
      "items": {
        "pattern": "^[A-Z](([a-z]+[A-Z]?)*)$",
        "type": "string"
      },
      "minItems": 1,
      "type": "array"
    },
    "Subclasses": {
      "items": {
        "enum": [
          "ADVERSE EVENT",
          "ALL",
          "MEDICAL DEVICE TIME-TO-EVENT",
          "NON-COMPARTMENTAL ANALYSIS",
          "TIME-TO-EVENT"
        ],
        "type": "string"
      },
      "type": "array"
    },
    "VariableName": {
      "pattern": "^(--[A-Z0-9]{1,6}|[A-Z][A-Z0-9]{0,7})$",
      "type": "string"
    },
    "Operator.json": {
      "additionalProperties": false,
      "anyOf": [
        {
          "properties": {
            "operator": {
              "const": "additional_columns_empty"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "additional_columns_not_empty"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "conformant_value_data_type",
              "markdownDescription": "\nValue Level Metadata Check against Define XML\n\nTrue if the types in the row match the VLM types specified in the define.xml\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "conformant_value_length",
              "markdownDescription": "\nValue Level Metadata Check against Define XML\n\nTrue if the lengths in the row match the VLM lengths specified in the define.xml\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "contains",
              "markdownDescription": "\nTrue if the value in `value` is a substring of the value in `name`\n\n> --TOXGR contains 'GRADE'\n\n```yaml\n- name: \"--TOXGR\"\n  operator: \"contains\"\n  value: \"GRADE\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "contains_all",
              "markdownDescription": "\nTrue if all values in `value` are contained within the variable `name`.\n\n> All of ('Screen Failure', 'Not Assigned', 'Not Treated', 'Unplanned Treatment') in ACTARM\n\n```yaml\n- name: \"ACTARM\"\n  operator: \"contains_all\"\n  value:\n    - \"Screen Failure\"\n    - \"Not Assigned\"\n    - \"Not Treated\"\n    - \"Unplanned Treatment\"\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "contains_case_insensitive",
              "markdownDescription": "\nTrue if the value in `value` is a case insensitive substring of the value in `name`\n\n> --TOXGR contains 'GRADE', regardless of text case\n\n```yaml\n- name: \"--TOXGR\"\n  operator: \"contains_case_insentisitve\"\n  value: \"grade\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "date_equal_to",
              "markdownDescription": "\nDate comparison. Compare `name` to `value`. Compares partial dates if `date_component` is specified.\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "date_greater_than",
              "markdownDescription": "\nDate comparison. Compare `name` to `value`. Compares partial dates if `date_component` is specified.\n\n> Year part of BRTHDTC > 2021\n\n```yaml\n- name: \"BRTHDTC\"\n  operator: \"date_greater_than\"\n  date_component: \"year\"\n  value: \"2021\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "date_greater_than_or_equal_to",
              "markdownDescription": "\nDate comparison. Compare `name` to `value`. Compares partial dates if `date_component` is specified.\n\n> Year part of BRTHDTC >= 2021\n\n```yaml\n- name: \"BRTHDTC\"\n  operator: \"date_greater_than_or_equal_to\"\n  date_component: \"year\"\n  value: \"2021\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "date_less_than",
              "markdownDescription": "\nDate comparison. Compare `name` to `value`. Compares partial dates if `date_component` is specified.\n\n> AEENDTC < AESTDTC\n\n```yaml\n- name: \"AEENDTC\"\n  operator: \"date_less_than\"\n  value: \"AESTDTC\"\n```\n\n> SSDTC < all DS.DSSTDTC when SSSTRESC = \"DEAD\"\n\n```yaml\nCheck:\n  all:\n    - name: \"SSSTRESC\"\n      operator: \"equal_to\"\n      value: \"DEAD\"\n    - name: \"SSDTC\"\n      operator: \"date_less_than\"\n      value: \"$max_ds_dsstdtc\"\nOperations:\n  - operator: \"max_date\"\n    domain: \"DS\"\n    name: \"DSSTDTC\"\n    id: \"$max_ds_dsstdtc\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "date_less_than_or_equal_to",
              "markdownDescription": "\nDate comparison. Compare `name` to `value`. Compares partial dates if `date_component` is specified.\n\n> AEENDTC <= AESTDTC\n\n```yaml\n- name: \"AEENDTC\"\n  operator: \"date_less_than_or_equal_to\"\n  value: \"AESTDTC\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "date_not_equal_to",
              "markdownDescription": "\nComplement of `date_equal_to`\n\nDate comparison. Compare `name` to `value`. Compares partial dates if `date_component` is specified.\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "does_not_contain",
              "markdownDescription": "\nComplement of `contains`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "does_not_contain_case_insensitive",
              "markdownDescription": "\nComplement of `contains_case_insensitive`\n\n> --TOXGR does not contain 'GRADE', regardless of text case\n\n```yaml\n- name: \"--TOXGR\"\n  operator: \"does_not_contain_case_insensitive\"\n  value: \"grade\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "does_not_equal_string_part",
              "markdownDescription": "\nComplement of `equals_string_part`\n"
            }
          },
          "required": [
            "operator",
            "value",
            "regex"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "does_not_have_next_corresponding_record",
              "markdownDescription": "\nComplement of `has_next_corresponding_record`\n"
            }
          },
          "required": [
            "operator",
            "ordering",
            "value",
            "within"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "does_not_reference_correct_codelist",
              "markdownDescription": "\nComplement of `references_correct_codelist`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "does_not_use_valid_codelist_terms"
            }
          },
          "required": [
            "operator",
            "value",
            "codelistlevel",
            "codelistcheck"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "empty",
              "markdownDescription": "\nValue presence\n\n> --OCCUR = null\n\n```yaml\n- name: --OCCUR\n  operator: empty\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "empty_within_except_last_row",
              "markdownDescription": "\n> SEENDTC is not empty when it is not the last record, grouped by USUBJID, sorted by SESTDTC\n\n```yaml\n- name: SEENDTC\n  operator: empty_within_except_last_row\n  ordering: SESTDTC\n  value: USUBJID\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "ends_with",
              "markdownDescription": "\nSubstring matching\n\n> DOMAIN ending with 'FOOBAR'\n\n```yaml\n- name: \"DOMAIN\"\n  operator: \"ends_with\"\n  value: \"FOOBAR\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "equal_to",
              "markdownDescription": "\nValue comparison. Works for both string and number.\n\n> --OCCUR = N\n\n```yaml\n- name: --OCCUR\n  operator: equal_to\n  value: \"N\"\n```\n\n> EXDOSE EQ 0\n\n```yaml\n- name: EXDOSE\n  operator: equal_to\n  value: 0\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "equal_to_case_insensitive",
              "markdownDescription": "\nCase insensitive `equal_to`\n\n> DSTERM is \"Informed consent obtained\"\n\n```yaml\n- name: DSTERM\n  operator: equal_to_case_insensitive\n  value: Informed consent obtained\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "equals_string_part",
              "markdownDescription": "\n> RDOMAIN equals characters 5 and 6 of SUPP dataset name\n\n```yaml\n- name: RDOMAIN\n  operator: equals_string_part\n  value: dataset_name\n  regex: \".{4}(..).*\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value",
            "regex"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "exists",
              "markdownDescription": "\nTrue if the column exists in the current dataframe. (Works for datasets and variables)\n\n> --OCCUR is present in dataset\n\n```yaml\n- name: \"--OCCUR\"\n  operator: \"exists\"\n```\n\n> Domain SJ exists\n\n```yaml\nRule Type: Domain Presence Check\nCheck:\n  all:\n    - name: \"SJ\"\n      operator: \"exists\"\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "greater_than",
              "markdownDescription": "\nValue comparison\n\n> TSVAL > 0\n\n```yaml\n- name: TSVAL\n  operator: greater_than\n  value: 0\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "greater_than_or_equal_to",
              "markdownDescription": "\nValue comparison\n\n> TSVAL >= 0\n\n```yaml\n- name: TSVAL\n  operator: greater_than_or_equal_to\n  value: 1\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "has_different_values",
              "markdownDescription": "\nComplement of `has_same_values`\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "has_equal_length",
              "markdownDescription": "\nLength comparison\n\n> Check whether variable values has equal length of another variable.\n\n```yaml\n- name: SEENDTC\n  operator: has_equal_length\n  value: SESTDTC\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "has_next_corresponding_record",
              "markdownDescription": "\nEnsures that a value of a variable `name` in one record is equal to the value of another variable `value` in the next corresponding record. The rows are grouped by `within` and ordered by `ordering`.\n\n> SEENDTC is equal to the SESTDTC of the next record within a USUBJID. Ordered by SESEQ\n\n```yaml\n- name: SEENDTC\n  operator: has_next_corresponding_record\n  value: SESTDTC\n  within: USUBJID\n  ordering: SESEQ\n```\n"
            }
          },
          "required": [
            "operator",
            "ordering",
            "value",
            "within"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "has_not_equal_length",
              "markdownDescription": "\nComplement of `has_equal_length`\n\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "has_same_values",
              "markdownDescription": "\nTrue if all values in `name` are the same\n\n> Condition: MHCAT ^= null\n> Rule: MHCAT ^= the same value for all records\n\n```yaml\nCheck:\n  all:\n    - name: MHCAT\n      operator: non_empty\n    - name: MHCAT\n      operator: has_same_values\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "invalid_duration",
              "markdownDescription": "\nDuration ISO-8601 check, returns True if a duration is not in ISO-8601 format. The negative parameter must be specified to indicate if negative durations are either allowed (True) or disallowed (False)\n\n> DURVAR is invalid (negative durations disallowed)\n\n```yaml\n- name: \"DURVAR\"\n  operator: \"invalid_duration\"\n  negative: False\n```\n\n"
            }
          },
          "required": [
            "operator",
            "negative"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "invalid_date",
              "markdownDescription": "\nDate check\n\n> BRTHDTC is invalid\n\n```yaml\n- name: \"BRTHDTC\"\n  operator: \"invalid_date\"\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_complete_date",
              "markdownDescription": "\nDate check\n\n> DM.RFSTDTC = complete date\n\n```yaml\n- name: \"RFSTDTC\"\n  operator: \"is_complete_date\"\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_contained_by",
              "markdownDescription": "\nValue in `name` compared against a list in `value`. The list can have literal values or be a reference to a `$variable`.\n\n> ACTARM in ('Screen Failure', 'Not Assigned', 'Not Treated', 'Unplanned Treatment')\n\n```yaml\n- name: \"ACTARM\"\n  operator: \"is_contained_by\"\n  value:\n    - \"Screen Failure\"\n    - \"Not Assigned\"\n    - \"Not Treated\"\n    - \"Unplanned Treatment\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_contained_by_case_insensitive",
              "markdownDescription": "\nValue in `name` case insensitive compared against a list in `value`. The list can have literal values or be a reference to a `$variable`.\n\n> ACTARM in ('Screen Failure', 'Not Assigned', 'Not Treated', 'Unplanned Treatment')\n\n```yaml\n- name: \"ACTARM\"\n  operator: \"is_contained_by_case_insensitive\"\n  value:\n    - \"Screen Failure\"\n    - \"Not Assigned\"\n    - \"Not Treated\"\n    - \"Unplanned Treatment\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_incomplete_date",
              "markdownDescription": "\nComplement of `is_complete_date`\n\nDate check\n\n> DM.RFSTDTC ^= complete date\n\n```yaml\n- name: \"RFSTDTC\"\n  operator: \"is_incomplete_date\"\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_contained_by",
              "markdownDescription": "\nComplement of `is_contained_by`\n\n> ARM not in ('Screen Failure', 'Not Assigned')\n\n```yaml\n- name: \"ARM\"\n  operator: \"is_not_contained_by\"\n  value:\n    - \"Screen Failure\"\n    - \"Not Assigned\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_contained_by_case_insensitive",
              "markdownDescription": "\nComplement of `is_contained_by_case_insensitive`\n\n> ARM not in ('Screen Failure', 'Not Assigned')\n\n```yaml\n- name: \"ARM\"\n  operator: \"is_not_contained_by_case_insensitive\"\n  value:\n    - \"Screen Failure\"\n    - \"Not Assigned\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_ordered_by",
              "markdownDescription": "\nComplement of `is_ordered_by`\n"
            }
          },
          "required": [
            "operator",
            "order"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_ordered_set",
              "markdownDescription": "\nComplement of `is_ordered_set`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_unique_relationship",
              "markdownDescription": "\nComplement of `is_unique_relationship`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_unique_set",
              "markdownDescription": "\nComplement of `is_unique_set`\n\n> --SEQ is not unique within DOMAIN, USUBJID, and --TESTCD\n\n```yaml\n- name: \"--SEQ\"\n  operator: is_not_unique_set\n  value:\n    - \"DOMAIN\"\n    - \"USUBJID\"\n    - \"--TESTCD\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_valid_reference",
              "markdownDescription": "\nComplement of `is_valid_reference`\n\n> IDVAR is an invalid reference as specified, given the domain context in RDOMAIN\n\n```yaml\nScopes:\n  Domains:\n    - RELREC\nCheck:\n  all:\n    - name: \"IDVAR\"\n      operator: is_not_valid_reference\n      context: \"RDOMAIN\"\n```\n"
            }
          },
          "required": [
            "operator",
            "context"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_not_valid_relationship",
              "markdownDescription": "\nComplement of `is_valid_relationship`\n\nRelationship Integrity Check\n\n> No records found in the domain referenced by RDOMAIN, where variable in IDVAR = value in IDVARVAL\n\n```yaml\nScopes:\n  Domains:\n    - RELREC\nCheck:\n  all:\n    - name: \"IDVAR\"\n      operator: is_not_valid_relationship\n      context: \"RDOMAIN\"\n      value: \"IDVARVAL\"\n```\n"
            }
          },
          "required": [
            "operator",
            "context",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_ordered_by",
              "markdownDescription": "\nTrue if the dataset rows are ordered by the values within `name`, given the ordering specified by `order`\n\n```yaml\nCheck:\n  all:\n    - name: --SEQ\n      operator: is_ordered_by\n      order: asc\n```\n"
            }
          },
          "required": [
            "operator",
            "order"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_ordered_set",
              "markdownDescription": "\nTrue if the dataset rows are in ascending order of the values within `name`, grouped by the values within `value`\n\n```yaml\nCheck:\n  all:\n    - name: --SEQ\n      operator: is_ordered_set\n      value: USUBJID\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_unique_relationship",
              "markdownDescription": "\nRelationship Integrity Check\n\n> AETERM and AEDECOD has a 1-to-1 relationship\n\n```yaml\n- name: AETERM\n  operator: is_unique_relationship\n  value: AEDECOD\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_consistent_across_dataset",
              "markdownDescription": "\nChecks if a variable maintains consistent values within groups defined by one or more grouping variables. Groups records by specified value(s) and validates that the target variable maintains the same value within each unique combination of grouping variables\n\nSingle grouping variable:\n\n```yaml\n- name: \"BGSTRESU\"\n  operator: is_consistent_across_dataset\n  value: \"USUBJID\"\n```\n\nMultiple grouping variables:\n\n```yaml\n- name: \"--STRESU\"\n  operator: is_consistent_across_dataset\n  value:\n    - \"--TESTCD\"\n    - \"--CAT\"\n    - \"--SCAT\"\n    - \"--SPEC\"\n    - \"--METHOD\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_unique_set",
              "markdownDescription": "\nRelationship Integrity Check\n\n> --SEQ is unique within DOMAIN, USUBJID, and --TESTCD\n\n```yaml\n- name: \"--SEQ\"\n  operator: is_unique_set\n  value:\n    - \"DOMAIN\"\n    - \"USUBJID\"\n    - \"--TESTCD\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_valid_reference",
              "markdownDescription": "\nReference\n\n> IDVAR is a valid reference as specified, given the domain context in RDOMAIN\n\n```yaml\nScopes:\n  Domains:\n    - RELREC\nCheck:\n  all:\n    - name: \"IDVAR\"\n      operator: is_valid_reference\n      context: \"RDOMAIN\"\n```\n"
            }
          },
          "required": [
            "operator",
            "context"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "is_valid_relationship",
              "markdownDescription": "\n> Records found in the domain referenced by RDOMAIN, where variable in IDVAR = value in IDVARVAL\n\n```yaml\nScopes:\n  Domains:\n    - RELREC\nCheck:\n  all:\n    - name: \"IDVAR\"\n      operator: is_valid_relationship\n      context: \"RDOMAIN\"\n      value: \"IDVARVAL\"\n```\n"
            }
          },
          "required": [
            "operator",
            "context",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "less_than",
              "markdownDescription": "\nValue comparison\n\n> TSVAL < 1\n\n```yaml\n- name: TSVAL\n  operator: less_than\n  value: 1\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "less_than_or_equal_to",
              "markdownDescription": "\nValue comparison\n\n> TSVAL <= 1\n\n```yaml\n- name: TSVAL\n  operator: less_than_or_equal_to\n  value: 1\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "longer_than",
              "markdownDescription": "\nLength comparison\n\n> SETCD value length > 8\n\n```yaml\n- name: \"SETCD\"\n  operator: \"longer_than\"\n  value: 8\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "longer_than_or_equal_to",
              "markdownDescription": "\nLength comparison\n\n> TSVAL value length >= 201\n\n```yaml\n- name: \"TSVAL\"\n  operator: \"longer_than_or_equal_to\"\n  value: 201\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "matches_regex",
              "markdownDescription": "\nRegular Expression value matching\n\n- Determine if each string starts with a match of a regular expression. Refer to this pandas documentation: https://pandas.pydata.org/docs/reference/api/pandas.Series.str.match.html\n- To \"search\" for a regex within the entire text, prefix the regex with `.*` and do not use anchors `^` , `$`\n- To do a \"fullmatch\" of a regex with the entire text, suffix the regex with an anchor `$` and do not prefix the regex with `.*`\n- For syntax guide, refer to this Python documentation: [Regular Expression HOWTO](https://docs.python.org/3/howto/regex.html).\n- Suggestion for an on-line regular expression logic. tester: https://regex101.com, choose the Python dialect.\n- For regex token visualization, try https://www.debuggex.com.\n\n> --DOSTXT value is non-numeric\n\n```yaml\n- name: --DOSTXT\n  operator: matches_regex\n  value: ^\\d*\\.?\\d*$\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "non_conformant_value_data_type",
              "markdownDescription": "\nComplement of `conformant_value_data_type`\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "non_conformant_value_length",
              "markdownDescription": "\nComplement of `conformant_value_length`\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "non_empty",
              "markdownDescription": "\nComplement of `empty`\n\n> --OCCUR ^= null\n\n```yaml\n- name: --OCCUR\n  operator: non_empty\n```\n\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "non_empty_within_except_last_row",
              "markdownDescription": "\nComplement of `empty_within_except_last_row`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_contains_all",
              "markdownDescription": "\nComplement of `contains_all`\n\n> All of ('Screen Failure', 'Not Assigned', 'Not Treated', 'Unplanned Treatment') not in ACTARM\n\n```yaml\n- name: \"ACTARM\"\n  operator: \"not_contains_all\"\n  value:\n    - \"Screen Failure\"\n    - \"Not Assigned\"\n    - \"Not Treated\"\n    - \"Unplanned Treatment\"\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_equal_to",
              "markdownDescription": "\nComplement of `equal_to`\n\n> --OCCUR ^= Y\n\n```yaml\n- name: --OCCUR\n  operator: not_equal_to\n  value: \"Y\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_equal_to_case_insensitive",
              "markdownDescription": "\nComplement of `equal_to_case_insensitive`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_exists",
              "markdownDescription": "\nComplement of `exists`\n\n> AEOCCUR not present in dataset\n\n```yaml\n- name: \"AEOCCUR\"\n  operator: \"not_exists\"\n```\n\n> Domain SJ does not exist\n\n```yaml\nRule Type: Domain Presence Check\nCheck:\n  all:\n    - name: \"SJ\"\n      operator: \"not_exists\"\n```\n"
            }
          },
          "required": [
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_matches_regex",
              "markdownDescription": "\nComplement of `matches_regex`\n\n> --TESTCD <= 8 chars and contains only letters, numbers, and underscores and can not start with a number\n\n```yaml\n- name: --TESTCD\n  operator: not_matches_regex\n  value: ^[A-Z_][A-Z0-9_]{0,7}$\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_prefix_matches_regex",
              "markdownDescription": "\nComplement of `prefix_matches_regex`\n"
            }
          },
          "required": [
            "operator",
            "prefix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_present_on_multiple_rows_within",
              "markdownDescription": "\nComplement of `present_on_multiple_rows_within`\n\n```yaml\n- operator: \"not_present_on_multiple_rows_within\"\n  name: \"RELID\"\n  value: 4 (optional)\n  within: \"USUBJID\"\n```\n"
            }
          },
          "required": [
            "operator",
            "within"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "not_suffix_matches_regex",
              "markdownDescription": "\nComplement of `suffix_matches_regex`\n\n> QNAM does not end with numbers\n\n```yaml\n- name: \"QNAM\"\n  operator: \"not_suffix_matches_regex\"\n  suffix: 2\n  value: \"\\d\\d\"\n```\n"
            }
          },
          "required": [
            "operator",
            "suffix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "prefix_is_contained_by",
              "markdownDescription": "\nTrue if the `prefix` number of characters beginning a string in `name` match one of the strings in the list in `value`\n\n> Check if a variable's domain identifier exists in the study\n\n```yaml\n- name: variable_name\n  operator: prefix_is_contained_by\n  prefix: 2\n  value: $study_domains\n```\n"
            }
          },
          "required": [
            "operator",
            "prefix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "prefix_equal_to",
              "markdownDescription": "\nTrue if the `prefix` number of characters beginning a string in `name` match the string in `value`\n\n```yaml\n- name: dataset_name\n  operator: prefix_equal_to\n  prefix: 2\n  value: DOMAIN\n```\n"
            }
          },
          "required": [
            "operator",
            "prefix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "prefix_is_not_contained_by",
              "markdownDescription": "\nComplement of `prefix_is_contained_by`\n"
            }
          },
          "required": [
            "operator",
            "prefix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "prefix_matches_regex",
              "markdownDescription": "\nTrue if the `prefix` number of characters beginning a string in `name` match a regular expression in `value`\n\n```yaml\n- name: DOMAIN\n  operator: prefix_matches_regex\n  prefix: 2\n  value: (AP|ap)\n```\n"
            }
          },
          "required": [
            "operator",
            "prefix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "prefix_not_equal_to",
              "markdownDescription": "\nComplement of `prefix_equal_to`\n"
            }
          },
          "required": [
            "operator",
            "prefix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "present_on_multiple_rows_within",
              "markdownDescription": "\nTrue if the same value of `name` is present on multiple rows, grouped by `within`. A maximum allowed number of occurrences can be specified in the value attribute. In this instance the value: 4 means that an error will be flagged if the same value appears more than 4 times within a USUBJID. By default the operator will flag any time a value appears more than once.\n\n```yaml\n- operator: \"present_on_multiple_rows_within\"\n  name: \"RELID\"\n  value: 4 (optional)\n  within: \"USUBJID\"\n```\n"
            }
          },
          "required": [
            "operator",
            "within"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "references_correct_codelist",
              "markdownDescription": "\nTrue if the codelist named within `value` is a valid codelist for the variable named within `name` in the define.xml.\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "shares_at_least_one_element_with",
              "markdownDescription": "\nWill raise an issue if at least one of the values in `name` is the same as one of the values in `value`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "shares_exactly_one_element_with",
              "markdownDescription": "\nWill raise an issue if exactly one of the values in `name` is the same as one of the values in `value`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "shares_no_elements_with",
              "markdownDescription": "\nWill raise an issue if the values in `name` do not share any of the values in `value`\n\n> Check if $dataset_variables shares no elements with $timing_variables\n\n```yaml\n  \"Check\": {\n    \"all\": [\n      {\n        \"name\": \"$dataset_variables\",\n        \"operator\": \"shares_no_elements_with\",\n        \"value\": \"$timing_variables\"\n      }\n    ]\n  },\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "shorter_than",
              "markdownDescription": "\nLength comparison\n\n> SETCD value length < 9\n\n```yaml\n- name: \"SETCD\"\n  operator: \"shorter_than\"\n  value: 9\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "shorter_than_or_equal_to",
              "markdownDescription": "\nLength comparison\n\n> TSVAL value length <= 200\n\n```yaml\n- name: \"TSVAL\"\n  operator: \"shorter_than_or_equal_to\"\n  value: 201\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "starts_with",
              "markdownDescription": "\nSubstring matching\n\n> DOMAIN beginning with 'AP'\n\n```yaml\n- name: \"DOMAIN\"\n  operator: \"starts_with\"\n  value: \"AP\"\n```\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "suffix_equal_to",
              "markdownDescription": "\nTrue if the `suffix` number of characters ending a string in `name` match the string in `value`\n\n```yaml\n- name: dataset_name\n  operator: suffix_equal_to\n  prefix: 2\n  value: DOMAIN\n```\n"
            }
          },
          "required": [
            "operator",
            "suffix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "suffix_is_contained_by",
              "markdownDescription": "\nTrue if the `suffix` number of characters ending a string in `name` match one of the strings in the list in `value`\n\n> Check if a supp's parent domain exists in the study\n\n```yaml\n- name: dataset_name\n  operator: suffix_is_contained_by\n  prefix: 2\n  value: $study_domains\n```\n"
            }
          },
          "required": [
            "operator",
            "suffix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "suffix_is_not_contained_by",
              "markdownDescription": "\nComplement of `suffix_is_contained_by`\n"
            }
          },
          "required": [
            "operator",
            "suffix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "suffix_matches_regex",
              "markdownDescription": "\nTrue if the `suffix` number of characters ending a string in `name` match a regular expression in `value`\n\n> QNAM ends with numbers\n\n```yaml\n- name: \"QNAM\"\n  operator: \"suffix_matches_regex\"\n  suffix: 2\n  value: \"\\d\\d\"\n```\n"
            }
          },
          "required": [
            "operator",
            "suffix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "suffix_not_equal_to",
              "markdownDescription": "\nComplement of `suffix_equal_to`\n"
            }
          },
          "required": [
            "operator",
            "suffix",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "target_is_not_sorted_by",
              "markdownDescription": "\nComplement of `target_is_sorted_by`\n"
            }
          },
          "required": [
            "operator",
            "value",
            "within"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "target_is_sorted_by",
              "markdownDescription": "\nTrue if the values in `name` are ordered according to the values specified by `value` grouped by the values in `within`. Each `value` requires a variable `name`, ordering specified by `order`, and the null position specified by `null_position`.\n\n```yaml\nCheck:\n  all:\n    - name: --SEQ\n      within: USUBJID\n      operator: target_is_sorted_by\n      value:\n        - name: --STDTC\n          order: asc\n          null_position: last\n```\n"
            }
          },
          "required": [
            "operator",
            "value",
            "within"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "value_does_not_have_multiple_references",
              "markdownDescription": "\nComplement of `value_has_multiple_references`\n\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "value_has_multiple_references",
              "markdownDescription": "\nTrue if the value in `name` has more than one count in the dictionary defined in `value`\n"
            }
          },
          "required": [
            "operator",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_metadata_equal_to",
              "markdownDescription": "\nCould be useful, for example, in checking variable permissibility in conjunction with the `variable_library_metadata` operation:\n\n```yaml\nCheck:\n  all:\n    - operator: variable_metadata_equal_to\n      value: Exp\n      metadata: $permissibility\n    - operator: not_exists\nOperations:\n  - id: $permissibility\n    operator: variable_library_metadata\n    name: core\n```\n"
            }
          },
          "required": [
            "operator",
            "metadata",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_metadata_not_equal_to",
              "markdownDescription": "\nComplement of `variable_metadata_equal_to`\n\n"
            }
          },
          "required": [
            "operator",
            "metadata",
            "value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "inconsistent_enumerated_columns",
              "markdownDescription": "\nChecks for inconsistencies in enumerated columns of a DataFrame. Starting with the smallest/largest enumeration of the given variable, returns True if VARIABLE(N+1) is populated but VARIABLE(N) is not populated. Repeats for all variables belonging to the enumeration. Note that the initial variable will not have an index (VARIABLE) and the next enumerated variable has index 1 (VARIABLE1).\n\nex: Check if there are inconsistencies in the TSVAL columns (TSVAL, TSVAL1, TSVAL2, etc.)\n\n```yaml\nCheck:\n  all:\n    - name: \"TSVAL\"\n      operator: \"inconsistent_enumerated_columns\"\n```\n"
            }
          },
          "required": [
            "operator",
            "name"
          ],
          "type": "object"
        }
      ],
      "properties": {
        "comparator": {
          "type": [
            "number",
            "string"
          ]
        },
        "context": {
          "type": "string"
        },
        "date_component": {
          "enum": [
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "microsecond"
          ],
          "type": "string"
        },
        "metadata": {
          "$ref": "#/$defs/Operations.json/properties/id"
        },
        "name": {
          "anyOf": [
            {
              "$ref": "#/$defs/Operations.json/properties/id"
            },
            {
              "$ref": "#/$defs/MetaVariables.json"
            },
            {
              "$ref": "#/$defs/VariableName"
            }
          ]
        },
        "negative": {
          "type": "boolean"
        },
        "codelistcheck": {
          "enum": [
            "code",
            "value"
          ],
          "type": "string"
        },
        "codelistlevel": {
          "enum": [
            "term",
            "codelist"
          ],
          "type": "string"
        },
        "operator": {
          "type": "string"
        },
        "order": {
          "enum": [
            "asc",
            "dsc"
          ],
          "type": "string"
        },
        "ordering": {
          "$ref": "#/$defs/VariableName"
        },
        "prefix": {
          "type": "integer"
        },
        "suffix": {
          "type": "integer"
        },
        "value": {
          "oneOf": [
            {
              "type": [
                "boolean",
                "number",
                "string"
              ]
            },
            {
              "items": {
                "type": [
                  "number"
                ]
              },
              "type": "array"
            },
            {
              "items": {
                "type": [
                  "string"
                ]
              },
              "type": "array"
            },
            {
              "items": {
                "properties": {
                  "name": {
                    "$ref": "#/$defs/Operator.json/properties/name"
                  },
                  "null_position": {
                    "enum": [
                      "first",
                      "last"
                    ],
                    "type": "string"
                  },
                  "order": {
                    "$ref": "#/$defs/Operator.json/properties/order"
                  }
                },
                "type": "object"
              },
              "type": "array"
            }
          ]
        },
        "value_is_literal": {
          "const": true
        },
        "within": {
          "$ref": "#/$defs/VariableName"
        },
        "regex": {
          "type": "string"
        }
      },
      "required": [
        "operator"
      ],
      "type": "object"
    },
    "Organization_CDISC.json": {
      "properties": {
        "Organization": {
          "const": "CDISC"
        },
        "Standards": {
          "items": {
            "oneOf": [
              {
                "properties": {
                  "Name": {
                    "const": "ADaMIG"
                  },
                  "References": {
                    "items": {
                      "properties": {
                        "Criteria": {
                          "properties": {
                            "Type": {
                              "const": "Failure"
                            }
                          },
                          "required": [
                            "Type"
                          ],
                          "type": "object"
                        },
                        "Origin": {
                          "const": "ADaM Conformance Rules"
                        },
                        "Rule Identifier": {
                          "properties": {
                            "Id": {
                              "pattern": "^\\d{1,3}(\\.\\d{1,2})?$",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "Version": {
                          "enum": [
                            "5.0"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    "minItems": 1,
                    "type": "array"
                  },
                  "Version": {
                    "enum": [
                      "1.0",
                      "1.1",
                      "1.2",
                      "1.3"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SDTMIG"
                  },
                  "References": {
                    "items": {
                      "properties": {
                        "Criteria": {
                          "properties": {
                            "Type": {
                              "const": "Success"
                            }
                          },
                          "required": [
                            "Type"
                          ],
                          "type": "object"
                        },
                        "Origin": {
                          "const": "SDTM and SDTMIG Conformance Rules"
                        },
                        "Rule Identifier": {
                          "properties": {
                            "Id": {
                              "pattern": "^CG\\d{4}$",
                              "type": "string"
                            },
                            "Version": {
                              "enum": [
                                "1",
                                "2",
                                "3"
                              ]
                            }
                          },
                          "type": "object"
                        },
                        "Version": {
                          "enum": [
                            "2.0"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    "minItems": 1,
                    "type": "array"
                  },
                  "Version": {
                    "enum": [
                      "3.2",
                      "3.3",
                      "3.4"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SENDIG"
                  },
                  "References": {
                    "items": {
                      "properties": {
                        "Criteria": {
                          "properties": {
                            "Type": {
                              "const": "Success"
                            }
                          },
                          "required": [
                            "Type"
                          ],
                          "type": "object"
                        },
                        "Origin": {
                          "const": "SEND Conformance Rules"
                        },
                        "Rule Identifier": {
                          "properties": {
                            "Id": {
                              "pattern": "^SEND\\d{1,3}(\\.\\d+)?$",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "Version": {
                          "enum": [
                            "5.0"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    "minItems": 1,
                    "type": "array"
                  },
                  "Version": {
                    "enum": [
                      "3.0",
                      "3.1",
                      "3.1.1"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SENDIG-DART"
                  },
                  "References": {
                    "items": {
                      "properties": {
                        "Criteria": {
                          "properties": {
                            "Type": {
                              "const": "Success"
                            }
                          },
                          "required": [
                            "Type"
                          ],
                          "type": "object"
                        },
                        "Origin": {
                          "const": "SEND Conformance Rules"
                        },
                        "Rule Identifier": {
                          "properties": {
                            "Id": {
                              "pattern": "^SEND\\d{1,3}(\\.\\d+)?$",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "Version": {
                          "enum": [
                            "5.0"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    "minItems": 1,
                    "type": "array"
                  },
                  "Version": {
                    "enum": [
                      "1.1",
                      "1.2"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SENDIG-GENETOX"
                  },
                  "References": {
                    "items": {
                      "properties": {
                        "Criteria": {
                          "properties": {
                            "Type": {
                              "const": "Success"
                            }
                          },
                          "required": [
                            "Type"
                          ],
                          "type": "object"
                        },
                        "Origin": {
                          "const": "SEND Conformance Rules"
                        },
                        "Rule Identifier": {
                          "properties": {
                            "Id": {
                              "pattern": "^SEND\\d{1,3}(\\.\\d+)?$",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "Version": {
                          "enum": [
                            "5.0"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    "minItems": 1,
                    "type": "array"
                  },
                  "Version": {
                    "enum": [
                      "1.0"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "TIG"
                  },
                  "References": {
                    "items": {
                      "properties": {
                        "Criteria": {
                          "properties": {
                            "Type": {
                              "const": "Success"
                            }
                          },
                          "required": [
                            "Type"
                          ],
                          "type": "object"
                        },
                        "Origin": {
                          "const": "TIG Conformance Rules"
                        },
                        "Rule Identifier": {
                          "properties": {
                            "Id": {
                              "pattern": "^TIG\\d{4}[a-z]?$",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "Version": {
                          "enum": [
                            "1.0"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    "minItems": 1,
                    "type": "array"
                  },
                  "Version": {
                    "enum": [
                      "1.0"
                    ]
                  },
                  "Substandard": {
                    "enum": [
                      "SDTM",
                      "SEND",
                      "ADaM",
                      "CDASH"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "USDM"
                  },
                  "References": {
                    "items": {
                      "properties": {
                        "Origin": {
                          "const": "USDM Conformance Rules"
                        },
                        "Rule Identifier": {
                          "properties": {
                            "Id": {
                              "pattern": "^DDF\\d{5}$",
                              "type": "string"
                            },
                            "Version": {
                              "enum": [
                                "1"
                              ]
                            }
                          },
                          "type": "object"
                        },
                        "Version": {
                          "enum": [
                            "1.0"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    "minItems": 1,
                    "type": "array"
                  },
                  "Version": {
                    "enum": [
                      "3.0",
                      "4.0"
                    ]
                  }
                },
                "type": "object"
              }
            ],
            "type": "object"
          },
          "minItems": 1,
          "type": "array"
        }
      },
      "type": "object"
    },
    "Organization_FDA.json": {
      "properties": {
        "Organization": {
          "const": "FDA"
        },
        "Standards": {
          "items": {
            "properties": {
              "References": {
                "items": {
                  "properties": {
                    "Citations": {
                      "items": {
                        "oneOf": [
                          {
                            "additionalProperties": false,
                            "properties": {
                              "Cited Guidance": {
                                "type": "string"
                              },
                              "Document": {
                                "const": "CDISC"
                              }
                            }
                          },
                          {
                            "additionalProperties": false,
                            "properties": {
                              "Cited Guidance": {
                                "type": "string"
                              },
                              "Document": {
                                "const": "FDA"
                              },
                              "Section": {
                                "pattern": "^(FDAB\\d{3}|TRC\\d{4}[A-Z]?|\\d{4}[A-Z])$",
                                "type": "string"
                              }
                            }
                          }
                        ],
                        "required": [
                          "Document",
                          "Cited Guidance"
                        ],
                        "type": "object"
                      },
                      "type": "array"
                    },
                    "Criteria": {
                      "properties": {
                        "Type": {
                          "const": "Success"
                        }
                      },
                      "required": [
                        "Type"
                      ],
                      "type": "object"
                    },
                    "Origin": {
                      "const": "FDA Business Rules"
                    },
                    "Rule Identifier": {
                      "properties": {
                        "Id": {
                          "pattern": "^(FB|CT|SD|SE)\\d{4}[A-Z]?$|^TRC.*$",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "Version": {
                      "enum": [
                        "1.5"
                      ]
                    }
                  },
                  "type": "object"
                },
                "minItems": 1,
                "type": "array"
              }
            },
            "oneOf": [
              {
                "properties": {
                  "Name": {
                    "const": "SDTMIG"
                  },
                  "Version": {
                    "enum": [
                      "3.2",
                      "3.3",
                      "3.4"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SENDIG"
                  },
                  "Version": {
                    "enum": [
                      "3.0",
                      "3.1",
                      "3.1.1"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SENDIG-AR"
                  },
                  "Version": {
                    "enum": [
                      "1.0"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SENDIG-DART"
                  },
                  "Version": {
                    "enum": [
                      "1.1",
                      "1.2"
                    ]
                  }
                },
                "type": "object"
              },
              {
                "properties": {
                  "Name": {
                    "const": "SENDIG-GENETOX"
                  },
                  "Version": {
                    "enum": [
                      "1.0"
                    ]
                  }
                },
                "type": "object"
              }
            ],
            "type": "object"
          },
          "minItems": 1,
          "type": "array"
        }
      },
      "type": "object"
    },
    "Operations.json": {
      "additionalProperties": false,
      "anyOf": [
        {
          "properties": {
            "operator": {
              "const": "codelist_extensible",
              "markdownDescription": "\nReturns a Series indicating whether a specified `codelist` is extensible. Used in conjunction with `codelist_terms` to determine if values outside the codelist are acceptable. From the above example, `$extensible` will contain a bool if the codelist PKUDUG is extensible in all rows of the column.\n"
            }
          },
          "required": [
            "id",
            "operator",
            "codelist"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "codelist_terms",
              "markdownDescription": "\nReturns a list of valid codelist/term values. Used for evaluating whether NCI code or submission values are valid based on controlled terminology. Expects three parameters: `codelists` which is a list of the codelist submission value(s) to retrieve, `level` which is the level of data (either \"codelist\" or \"term\") at which to return data from, and `returntype` which is the type of values to return, either \"code\" for NCI Code(s) or \"value\" for submission value(s)\n\n```yaml\n-   \"Check\": {\n    \"all\": [\n      {\n        \"name\": \"PPSTRESU\",\n        \"operator\": \"is_not_contained_by\",\n        \"value\": \"$terms\"\n      },\n      {\n        \"name\": \"$extensible\",\n        \"operator\": \"equal_to\",\n        \"value\": true\n      }\n    ]\n},\n-   \"Operations\": [\n      {\n        \"id\": \"$terms\",\n        \"operator\": \"codelist_terms\",\n        \"codelists\": [\"PKUDUG\"],\n        \"level\": \"term\",\n        \"returntype\": \"value\"\n      },\n      {\n        \"id\": \"$extensible\",\n        \"codelist\": \"PKUDUG\",\n        \"operator\": \"codelist_extensible\"\n      }\n    ],\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "codelists",
            "level",
            "returntype"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "define_extensible_codelists",
              "markdownDescription": "\nReturns a list of valid extensible codelist term's submission values. Used for evaluating whether submission values are valid based on controlled terminology. Expects the parameter `codelists` which is a list of the codelist submission value(s) to retrieve. If the codelist argument is `[\"All\"]` will return all extensible terms for the CT in a list.\n\n```yaml\n    {\n      \"id\": \"$ext_value\",\n      \"codelist\": [\"ALL\"],\n      \"operator\": \"define_extensible_codelists\"\n    },\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "codelists"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "define_variable_metadata",
              "markdownDescription": "\nIf a target variable `name` is specified, returns the specified metadata in the define for the specified target variable.\n\n- Input\n\n  ```yaml\n  - operation: define_variable_metadata\n    attribute_name: define_variable_label\n    name: LBTESTCD\n    id: $LBTESTCD_VARIABLE_LABEL\n  ```\n\n- Output\n\n  `Laboratory Test Code`\n\nIf no target variable `name` specified, returns a dictionary containing the specified metadata in the define for all variables.\n\n- Input\n\n  ```yaml\n  - operation: define_variable_metadata`\n    attribute_name: define_variable_label`\n    id: $VARIABLE_LABEL`\n  ```\n\n- Output\n\n  ```json\n  {\n    \"STUDYID\": \"Study Identifier\",\n    \"USUBJID\": \"Unique Subject Identifier\",\n    \"LBTESTCD\": \"Laboratory Test Code\",\n    \"...\": \"...\"\n  }\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "attribute_name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "distinct",
              "markdownDescription": "\nGet a distinct list of values for the given `name`. If a `group` list is specified, the distinct value list will be grouped by the variables within `group`.\n\nIf `group` is provided, `group_aliases` may also be provided to assign new grouping variable names so that results grouped by the values in one set of grouping variables can be merged onto a dataset according to the same grouping value(s) stored in different set of grouping variables. When both `group` and `group_aliases` are provided, columns are renamed according to corresponding list position (i.e., the 1st column in `group` is renamed to the 1st column in `group_aliases`, etc.). If there are more columns listed in `group` than in `group_aliases`, only the `group` columns with corresponding `group_aliases` columns will be renamed. If there are more columns listed in `group_aliases` than in `group`, the extra column names in `group_aliases` will be ignored. See [record_count](#record_count) for an example of the use of `group_aliases`.\n\n```yaml\nCheck:\n  all:\n    - name: SSSTRESC\n      operator: equal_to\n      value: DEAD\n      value_is_literal: true\n    - name: $ds_dsdecod\n      operator: does_not_contain\n      value: DEATH\n      value_is_literal: true\nOperations:\n  - operator: distinct\n    domain: DS\n    name: DSDECOD\n    id: $ds_dsdecod\n    group:\n      - USUBJID\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "domain_is_custom",
              "markdownDescription": "\nChecks whether the domain is in the set of domains within the provided standard.\n\n- Input\n\n  Target Domain: `XY`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  ```yaml\n  Operations:\n    - operator: domain_is_custom\n      id: $domain_is_custom\n  ```\n\n- Output\n\n  `true`\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "domain_label",
              "markdownDescription": "\nReturns the label for the domain the operation is executing on within the provided standard.\n\n- Input.\n\n  Target Domain: `LB`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  ```yaml\n  Operations:\n    - operator: domain_label\n      id: $domain_label\n  ```\n\n- Output\n\n  `Laboratory Test Results`\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "dy",
              "markdownDescription": "\nCalculates the number of days between the DTC and RFSTDTC. The Study Day value is incremented by 1 for each date following RFSTDTC. Dates prior to RFSTDTC are decreased by 1, with the date preceding RFSTDTC designated as Study Day -1 (there is no Study Day 0). . . . All Study Day values are integers. Thus, to calculate Study Day:\n\n- `--DY = (date portion of --DTC) - (date portion of RFSTDTC) + 1 if --DTC is on or after RFSTDTC`\n- `--DY = (date portion of --DTC) - (date portion of RFSTDTC) if --DTC precedes RFSTDTC`\n\nThis algorithm should be used across all domains.\n\n```yaml\nCheck:\n  all:\n    - name: --DY\n      operator: non_empty\n    - name: --DTC\n      operator: is_complete_date\n    - name: RFSTDTC\n      operator: is_complete_date\n    - name: --DY\n      operator: not_equal_to\n      value: $dy`\nOperations:\n  - name: --DTC\n    operator: dy\n    id: $dy\nMatch Datasets:\n  - Name: DM\n    Keys:\n      - USUBJID\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "extract_metadata",
              "markdownDescription": "\nReturns the requested dataset level metadata value for the current dataset. Possible `name` values are:\n\n- `dataset_size`\n- `dataset_location`\n- `dataset_name`\n- `dataset_label`\n\nExample\n\n- Input:\n\n  Target domain: `LB`\n\n  ```yaml\n  - name: dataset_label\n    operator: extract_metadata\n    id: $dataset_label\n  ```\n\n- Output:\n\n  `Laboratory Test Results`\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "expected_variables",
              "markdownDescription": "\nReturns the expected variables for the domain in the current standard.\n\n- Input:\n\n  Target Domain: `LB`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  ```yaml\n  - operation: expected_variables`\n    id: $expected_variables`\n  ```\n\n- Output:\n\n  ```json\n  [\"LBCAT\", \"LBORRES\", \"LBORRESU\", \"...\"]\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "get_codelist_attributes",
              "markdownDescription": "\nFetches attribute values for a codelist specified in a dataset (like TS)\n\n```yaml\n- id: $TERM_CCODES\n  name: TSVCDREF\n  operation: get_codelist_attributes\n  ct_attribute: Term CCODE\n  ct_version: TSVCDVER\n  ct_packages:\n    - sdtmct-2020-03-27\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name",
            "ct_attribute",
            "ct_packages",
            "ct_version"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "get_column_order_from_dataset",
              "markdownDescription": "\nReturns list of dataset columns in order\n\n```yaml\nCheck:\n  all:\n    - name: $column_order_from_dataset\n      operator: is_not_ordered_by\n      value: $column_order_from_library\nOperations:\n  - id: $column_order_from_library\n    operator: get_column_order_from_library\n  - id: $column_order_from_dataset\n    operator: get_column_order_from_dataset\n```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "get_column_order_from_library",
              "markdownDescription": "\nFetches column order for a given domain from the CDISC library. The lists with column names are sorted in accordance to \"ordinal\" key of library metadata.\n\n```yaml\nRule Type: Variable Metadata Check\nCheck:\n  all:\n    - name: variable_name\n      operator: is_not_contained_by\n      value: $ig_variables\nOperations:\n  - id: $ig_variables\n    operator: get_column_order_from_library\n```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "get_model_column_order",
              "markdownDescription": "\nFetches column order for a given model class from the CDISC library. The lists with column names are sorted in accordance to \"ordinal\" key of library metadata.\n\n```yaml\nRule Type: Variable Metadata Check\nCheck:\n  all:\n    - name: variable_name\n      operator: is_not_contained_by\n      value: $model_variables\nOperations:\n  - id: $model_variables\n    operator: get_model_column_order\n```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "get_model_filtered_variables",
              "markdownDescription": "\nFetches variable level library model properties filtered by the provided `key_name` and `key_value`\n\nExample\n\n- Input\n\n  Target Domain: `LB`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  ```yaml\n  - operation: get_model_filtered_variables`\n    id: $model_filtered_variables`\n    key_name: \"role\"\n    key_value: \"Timing\"\n  ```\n\n- Output\n\n  ```json\n  [\"VISITNUM\", \"VISIT\", \"VISITDY\", \"TAETORD\", \"...\"]\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "key_name",
            "key_value"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "get_parent_model_column_order",
              "markdownDescription": "\nFetches column order for a given SUPP's parent model class from the CDISC library. The lists with column names are sorted in accordance to \"ordinal\" key of library metadata.\n\n```yaml\nCheck:\n  all:\n    - operator: is_not_contained_by\n      value: $parent_model_variables\nOperations:\n  - id: $parent_model_variables\n    operator: get_parent_model_column_order\n```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "label_referenced_variable_metadata",
              "markdownDescription": "\nGenerates a dataframe where each record in the dataframe is the library ig variable metadata corresponding with the variable label found in the column provided in `name`\n\n- Input\n\n  Target Dataset: `SUPPLB`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  Dataset:\n\n  ```json\n  {\n    \"STUDYID\": [\"STUDY1\", \"STUDY1\", \"STUDY1\"],\n    \"USUBJID\": [\"SUBJ1\", \"SUBJ1\", \"SUBJ1\"],\n    \"QLABEL\": [\"Toxicity\", \"Viscosity\", \"Analysis Method\"]\n  }\n  ```\n\n  Rule:\n\n  ```yaml\n  - operation: label_referenced_variable_metadata\n    id: $label_referenced_variable_metadata\n    name: \"QLABEL\"\n  ```\n\n- Output\n\n  ```json\n  {\n    \"STUDYID\": [\"STUDY1\", \"STUDY1\", \"STUDY1\"],\n    \"USUBJID\": [\"SUBJ1\", \"SUBJ1\", \"SUBJ1\"],\n    \"QLABEL\": [\"Toxicity\", \"Viscosity\", \"Analysis Method\"],\n    \"$label_referenced_variable_name\": [\"LBTOX\", null, \"LBANMETH\"],\n    \"$label_referenced_variable_role\": [\n      \"Variable Qualifier\",\n      null,\n      \"Record Qualifier\"\n    ],\n    \"$label_referenced_variable_ordinal\": [44, null, 38],\n    \"$label_referenced_variable_label\": [\"Toxicity\", null, \"Analysis Method\"]\n  }\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "max",
              "markdownDescription": "\nIf no `group` is provided, returns the max value in `name`. If `group` is provided, returns the max value in `name`, within each unique set of the grouping variables.\n\n```yaml\nCheck:\n  all:\n    - name: \"$max_age\"\n      operator: \"greater_than\"\n      value: \"MAXAGE\"\nOperations:\n  - operator: \"max\"\n    domain: \"DM\"\n    name: \"AGE\"\n    id: \"$max_age\"\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "max_date",
              "markdownDescription": "\nIf no `group` is provided, returns the max date value in `name`. If `group` is provided, returns the max date value in `name`, within each unique set of the grouping variables.\n\n```yaml\nCheck:\n  all:\n    - name: USUBJID\n      operator: is_contained_by\n      value: $ex_usubjid\n    - name: RFXENDTC\n      operator: not_equal_to\n      value: $max_ex_exstdtc\n    - name: RFXENDTC\n      operator: not_equal_to\n      value: $max_ex_exendtc\nOperations:\n  - operator: distinct\n    domain: EX\n    name: USUBJID\n    id: $ex_usubjid\n  - operator: max_date\n    domain: EX\n    name: EXSTDTC\n    id: $max_ex_exstdtc\n    group:\n      - USUBJID\n  - operator: max_date\n    domain: EX\n    name: EXENDTC\n    id: $max_ex_exendtc\n    group:\n      - USUBJID\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "mean",
              "markdownDescription": "\nExample: AAGE > mean(DM.AGE), where AAGE is a fictitious NSV\n\n```yaml\nCheck:\n  all:\n    - name: \"AAGE\"\n      operator: \"greater_than\"\n      value: \"$average_age\"\nOperations:\n  - operator: \"mean\"\n    domain: \"DM\"\n    name: \"AGE\"\n    id: \"$average_age\"\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "min",
              "markdownDescription": "\nIf no `group` is provided, returns the min value in `name`. If `group` is provided, returns the min value in `name`, within each unique set of the grouping variables.\n\n```yaml\nCheck:\n  all:\n    - name: \"$min_age\"\n      operator: \"less_than\"\n      value: \"MINAGE\"\nOperations:\n  - operator: \"min\"\n    domain: \"DM\"\n    name: \"AGE\"\n    id: \"$min_age\"\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "min_date",
              "markdownDescription": "\nIf no `group` is provided, returns the min date value in `name`. If `group` is provided, returns the min date value in `name`, within each unique set of the grouping variables.\n\nExample: RFSTDTC is greater than min AE.AESTDTC for the current USUBJID\n\n```yaml\nCheck:\n  all:\n    - name: \"RFSTDTC\"\n      operator: \"date_greater_than\"\n      value: \"$ae_aestdtc\"\nOperations:\n  - operator: \"min_date\"\n    domain: \"AE\"\n    name: \"AESTDTC\"\n    id: \"$ae_aestdtc\"\n    group:\n      - USUBJID\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "name_referenced_variable_metadata",
              "markdownDescription": "\nGenerates a dataframe where each record in the dataframe is the library ig variable metadata corresponding with the variable name found in the column provided in `name`\n\n- Input\n\n  Target Dataset: `SUPPLB`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  Dataset:\n\n  ```json\n  {\n    \"STUDYID\": [\"STUDY1\", \"STUDY1\", \"STUDY1\"],\n    \"USUBJID\": [\"SUBJ1\", \"SUBJ1\", \"SUBJ1\"],\n    \"QNAM\": [\"Toxicity\", \"LBVISCOS\", \"Analysis Method\"]\n  }\n  ```\n\n  Rule:\n\n  ```yaml\n  - operation: name_referenced_variable_metadata`\n    id: $name_referenced_variable_metadata`\n    name: \"QNAM\"\n  ```\n\n- Output\n\n  ```json\n  {\n    \"STUDYID\": [\"STUDY1\", \"STUDY1\", \"STUDY1\"],\n    \"USUBJID\": [\"SUBJ1\", \"SUBJ1\", \"SUBJ1\"],\n    \"QNAM\": [\"LBTOX\", \"LBVISCOS\", \"LBANMETH\"],\n    \"$label_referenced_variable_name\": [\"LBTOX\", null, \"LBANMETH\"],\n    \"$label_referenced_variable_role\": [\n      \"Variable Qualifier\",\n      null,\n      \"Record Qualifier\"\n    ],\n    \"$label_referenced_variable_ordinal\": [44, null, 38],\n    \"$label_referenced_variable_label\": [\"Toxicity\", null, \"Analysis Method\"]\n  }\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "permissible_variables",
              "markdownDescription": "\nReturns the permissible variables for a given domain and standard\n\n- Input:\n\n  Target Domain: `LB`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  ```yaml\n  - operation: permissible_variables`\n    id: $permissible_variables`\n  ```\n\n- Output:\n\n  ```json\n  [\"LBGRPID\", \"LBREFID\", \"LBSPID\", \"...\"]\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "record_count",
              "markdownDescription": "\nIf no `filter` or `group` is provided, returns the number of records in the dataset. If `filter` is provided, returns the number of records in the dataset that contain the value(s) in the corresponding column(s) provided in the filter. If `group` is provided, returns the number of rows matching each unique set of the grouping variables. If both `filter` and `group` are provided, returns the number of records in the dataset that contain the value(s) in the corresponding column(s) provided in the filter that also match each unique set of the grouping variables.\n\nIf `group` is provided, `group_aliases` may also be provided to assign new grouping variable names so that results grouped by the values in one set of grouping variables can be merged onto a dataset according to the same grouping value(s) stored in different set of grouping variables. When both `group` and `group_aliases` are provided, columns are renamed according to corresponding list position (i.e., the 1st column in `group` is renamed to the 1st column in `group_aliases`, etc.). If there are more columns listed in `group` than in `group_aliases`, only the `group` columns with corresponding `group_aliases` columns will be renamed. If there are more columns listed in `group_aliases` than in `group`, the extra column names in `group_aliases` will be ignored.\n\nExample: return the number of records in a dataset.\n\n```yaml\n- operation: record_count\n  id: $records_in_dataset\n```\n\nExample: return the number of records where STUDYID = \"CDISC01\" and FLAGVAR = \"Y\".\n\n```yaml\n- operation: record_count\n  id: $flagged_cdisc01_records_in_dataset\n  filter:\n    STUDYID: \"CDISC01\"\n    FLAGVAR: \"Y\"\n```\n\nExample: return the number of records grouped by USUBJID.\n\n```yaml\n- operation: record_count\n  id: $records_per_usubjid\n  group:\n    - USUBJID\n```\n\nExample: return the number of records grouped by USUBJID where FLAGVAR = \"Y\".\n\n```yaml\n- operation: record_count\n  id: $flagged_records_per_usubjid\n  group:\n    - USUBJID\n  filter:\n    FLAGVAR: \"Y\"\n```\n\nExample: return the number of records grouped by USUBJID and IDVARVAL where QNAM = \"TEST1\" and IDVAR = \"GROUPID\", renaming the IDVARVAL column to GROUPID for subsequent merging.\n\n```yaml\n- operation: record_count\n  id: $test1_records_per_usubjid_groupid\n  group:\n    - USUBJID\n    - IDVARVAL\n  filter:\n    QNAM: \"TEST1\"\n    IDVAR: \"GROUPID\"\n  group_aliases:\n    - USUBJID\n    - GROUPID\n```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "required_variables",
              "markdownDescription": "\nReturns the required variables for a given domain and standard\n\n- Input:\n\n  Target Domain: `LB`\n\n  Product: `sdtmig`\n\n  Version: `3-4`\n\n  ```yaml\n  - operation: required_variables\n    id: $required_variables\n  ```\n\n- Output:\n\n  ```json\n  [\"STUDYID\", \"DOMAIN\", \"USUBJID\", \"LBSEQ\", \"LBTESTCD\", \"LBTEST\"]\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "study_domains",
              "markdownDescription": "\nReturns a list of the domains in the study\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "dataset_names",
              "markdownDescription": "\nReturns a list of the submitted dataset filenames in all uppercase\n\nex. if TS.xpt, AE.xpt, EC.xpt, and SUPPEC.xpt are submitted -> [TS, AE, EC, SUPPEC] will be returned\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_codelist_dates",
              "markdownDescription": "\nReturns the valid codelist dates for a given standard\n\nGiven a list of codelists:\n\n```json\n[\n  \"sdtmct-2023-10-26\",\n  \"sdtmct-2023-12-13\",\n  \"adamct-2023-12-13\",\n  \"cdashct-2023-05-19\"\n]\n```\n\nand standard: `sdtmig`\n\nthe operation will return\n\n```json\n[\"2023-10-26\", \"2023-12-13\"]\n```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_define_external_dictionary_version",
              "markdownDescription": "\nReturns true if the version of an external dictionary provided in the define.xml file matches\nthe version parsed from the dictionary files.\n\nInput:\n\n```yaml\n- operation: valid_define_external_dictionary_version\n  id: $is_valid_loinc_version\n  external_dictionary_type: loinc\n```\n\nOutput:\n\n```json\n[true, true, true, true]\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "external_dictionary_type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_external_dictionary_value",
              "markdownDescription": "\nReturns true if the target variable contains a valid external dictionary value, otherwise false\n\nCan be case insensitive by setting `case_sensitive` attribute to false. It is true by default.\n\nInput:\n\n```yaml\n- operation: valid_external_dictionary_value\n  name: --DECOD\n  id: $is_valid_decod_value\n  external_dictionary_type: meddra\n  dictionary_term_type: PT\n  case_sensitive: false\n```\n\nOutput:\n\n```json\n[true, false, false, true]\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name",
            "external_dictionary_type",
            "dictionary_term_type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_external_dictionary_code",
              "markdownDescription": "\nReturns true if the target variable contains a valid external dictionary code, otherwise false\n\nInput:\n\n```yaml\n- operation: valid_external_dictionary_code\n  name: --COD\n  id: $is_valid_cod_code\n  external_dictionary_type: meddra\n  dictionary_term_type: PT\n```\n\nOutput:\n\n```json\n[true, false, false, true]\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name",
            "external_dictionary_type",
            "dictionary_term_type"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_external_dictionary_code_term_pair",
              "markdownDescription": "\nReturns true if the row in the dataset contains a matching pair of code and term, otherwise false\n\nFor this operator, the name parameter should contain the name of the variable containing the code, and the\nexternal_dictionary_term_variable parameter should contain the name of the variable containing the term\nInput:\n\n```yaml\n- operation: valid_external_dictionary_code_term_pair\n  name: --COD\n  id: $is_valid_loinc_code_term_pair\n  external_dictionary_type: loinc\n  external_dictionary_term_variable: --DECOD\n```\n\nOutput:\n\n```json\n[true, false, false, true]\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name",
            "external_dictionary_type",
            "external_dictionary_term_variable"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_meddra_code_references",
              "markdownDescription": "\nDetermines whether the values are valid in the following variables:\n\n- `--SOCCD`\n- `--HLGTCD`\n- `--HLTCD`\n- `--PTCD`\n- `--LLTCD`\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_meddra_code_term_pairs",
              "markdownDescription": "\nDetermines whether the values are valid in the following variable pairs:\n\n- `--SOCCD`, `--SOC`\n- `--HLGTCD`, `--HLGT`\n- `--HLTCD`, `--HLT`\n- `--PTCD`, `--DECOD`\n- `--LLTCD`, `--LLT`\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_meddra_term_references",
              "markdownDescription": "\nDetermines whether the values are valid in the following variables:\n\n- `--SOC`\n- `--HLGT`\n- `--HLT`\n- `--DECOD`\n- `--LLT`\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "valid_whodrug_references",
              "markdownDescription": "\nChecks if a reference to whodrug term in `name` points to the existing code in Atc Text (INA) file.\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_count",
              "markdownDescription": "\nReturns a mapping of variable names to the number of times that variable appears in a domain within the study.\n\n- Input\n\n  ```json\n  {\n    \"AE\": [\"STUDYID\", \"DOMAIN\", \"USUBJID\", \"AETERM\", \"AEENDTC\"],\n    \"LB\": [\"STUDYID\", \"DOMAIN\", \"USUBJID\", \"LBTESTCD\", \"LBENDTC\"]\n  }\n  ```\n\n- Output\n\n  ```json\n  {\n    \"STUDYID\": 2,\n    \"DOMAIN\": 2,\n    \"USUBJID\": 2,\n    \"--TERM\": 1,\n    \"--TESTCD\": 1,\n    \"--ENDTC\": 2\n  }\n  ```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_exists",
              "markdownDescription": "\nFlag an error if MIDS is in the dataset currently being evaluated and the TM domain is not present in the study\n\n```yaml\nRule Type: Domain Presence Check\nCheck:\n  all:\n    - name: $MIDS_EXISTS\n      operator: equal_to\n      value: true\n    - name: TM\n      operator: not_exists\nOperations:\n  - id: $MIDS_EXISTS\n    name: MIDS\n    operator: variable_exists\n```\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_is_null",
              "markdownDescription": "\nTrue if variable is missing or if all values within a variable are null or empty string\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_library_metadata",
              "markdownDescription": "\nGet the metadata value from the library for all variables in the current dataset. Metadata attribute is specified by the `name`.\n\nResult\n\n```json\n{\n  \"STUDYID\": \"Req\",\n  \"DOMAIN\": \"Req\",\n  \"AEGRPID\": \"Perm\",\n  \"AETERM\": \"Req\",\n  \"AELLT\": \"Exp\",\n  \"...\": \"...\"\n}\n```\n\n> Condition: Variable Core Status = Required\n\n> Rule: Variable ^= null\n\n```yaml\nCheck:\n  any:\n    - all:\n        - operator: variable_metadata_equal_to\n          value: Req\n          metadata: $var_perm\n        - operator: empty\nOperations:\n  - id: $var_perm\n    operator: variable_library_metadata\n    name: core\n```\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_names",
              "markdownDescription": "\nReturn the set of variable names from the library for the given standard\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "variable_value_count",
              "markdownDescription": "\nGiven a variable `name`, returns a mapping of variable values to the number of times that value appears in the variable within all datasets in the study.\n"
            }
          },
          "required": [
            "id",
            "operator",
            "name"
          ],
          "type": "object"
        },
        {
          "properties": {
            "operator": {
              "const": "whodrug_code_hierarchy",
              "markdownDescription": "\nDetermines whether the values are valid in the following variables:\n\n- `--DECOD`\n- `--CLAS`\n- `--CLASCD`\n"
            }
          },
          "required": [
            "id",
            "operator"
          ],
          "type": "object"
        }
      ],
      "properties": {
        "attribute_name": {
          "$ref": "#/$defs/MetaVariables.json"
        },
        "case_sensitive": {
          "type": "boolean"
        },
        "ct_attribute": {
          "type": "string"
        },
        "ct_packages": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "ct_version": {
          "type": "string"
        },
        "dictionary_term_type": {
          "enum": [
            "LLT",
            "PT",
            "HLT",
            "HLGT",
            "SOC"
          ]
        },
        "domain": {
          "anyOf": [
            {
              "$ref": "#/$defs/Dataset"
            },
            {
              "$ref": "#/$defs/DataStructure"
            }
          ]
        },
        "external_dictionary_type": {
          "enum": [
            "meddra"
          ]
        },
        "filter": {
          "type": "object"
        },
        "group": {
          "items": {
            "$ref": "#/$defs/VariableName"
          },
          "type": "array"
        },
        "group_aliases": {
          "items": {
            "$ref": "#/$defs/VariableName"
          },
          "type": "array"
        },
        "id": {
          "type": "string"
        },
        "key_name": {
          "enum": [
            "definition",
            "examples",
            "label",
            "name",
            "notes",
            "ordinal",
            "role",
            "simpleDatatype",
            "variableCcode"
          ],
          "type": "string"
        },
        "key_value": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "operator": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "operator"
      ],
      "type": "object"
    },
    "Rule_Type.json": {
      "anyOf": [
        {
          "const": "Dataset Contents Check against Define XML and Library Metadata",
          "title": "Content data at record level, define xml metadata at variable level, and library metadata at variable level",
          "markdownDescription": "\n#### Columns\n\nColumns are the columns within the original dataset\n\n#### Rule Macro\n\nAttach define xml metadata at variable level and library metadata at variable level\n"
        },
        {
          "const": "Dataset Metadata Check",
          "title": "Content metadata at dataset level",
          "markdownDescription": "\n#### Columns\n\n- `dataset_label`\n- `dataset_location`\n- `dataset_name`\n- `dataset_size`\n\n#### Example\n\n```yaml\n- name: dataset_name\n  operator: longer_than\n  value: 6\n```\n"
        },
        {
          "const": "Dataset Metadata Check against Define XML",
          "title": "Content metadata at dataset level and define xml metadata at dataset level",
          "markdownDescription": "\n#### Columns\n\n- `dataset_size`\n- `dataset_location`\n- `dataset_name`\n- `dataset_label`\n- `dataset_domain`\n- `define_dataset_name`\n- `define_dataset_label`\n- `define_dataset_location`\n- `define_dataset_domain`\n- `define_dataset_class`\n- `define_dataset_structure`\n- `define_dataset_is_non_standard`\n- `define_dataset_variables`\n\n#### Rule Macro\n\nAllows comparing content metadata to define xml metadata of the same name.\n\n#### Example\n\n```yaml\nall:\n  - name: dataset_name\n    operator: not_equal_to\n    value: define_dataset_name\n```\n\nOr\n\n```yaml\nany:\n  - name: dataset_name\n    operator: empty\n  - name: define_dataset_name\n    operator: empty\n```\n"
        },
        {
          "const": "Define Item Group Metadata Check",
          "title": "Define xml metadata at dataset level",
          "markdownDescription": "\n#### Columns\n\n- `define_dataset_name`\n- `define_dataset_label`\n- `define_dataset_location`\n- `define_dataset_class`\n- `define_dataset_structure`\n- `define_dataset_is_non_standard`\n- `define_dataset_variables`\n"
        },
        {
          "const": "Define Item Metadata Check",
          "title": "Define xml metadata at variable level",
          "markdownDescription": "\n#### Columns\n\n- `define_variable_name`\n- `define_variable_label`\n- `define_variable_data_type`\n- `define_variable_role`\n- `define_variable_size`\n- `define_variable_ccode`\n- `define_variable_format`\n- `define_variable_allowed_terms`\n- `define_variable_origin_type`\n- `define_variable_is_collected`\n- `define_variable_has_no_data`\n- `define_variable_order_number`\n- `define_variable_has_codelist`\n- `define_variable_codelist_coded_values`\n- `define_variable_has_comment`\n\n#### Rule Macro\n\nAttach variable codelist and codelist terms\n"
        },
        {
          "const": "Define Item Metadata Check against Library Metadata",
          "title": "Define xml metadata at variable level and corresponding library variable metadata",
          "markdownDescription": "\n#### Columns\n\n- `define_variable_name`\n- `define_variable_label`\n- `define_variable_data_type`\n- `define_variable_role`\n- `define_variable_size`\n- `define_variable_ccode`\n- `define_variable_format`\n- `define_variable_allowed_terms`\n- `define_variable_origin_type`\n- `define_variable_is_collected`\n- `define_variable_has_no_data`\n- `define_variable_order_number`\n- `define_variable_has_codelist`\n- `define_variable_codelist_coded_values`\n- `define_variable_has_comment`\n- `library_variable_name`\n- `library_variable_order_number`\n- `library_variable_label`\n- `library_variable_data_type`\n- `library_variable_role`\n- `library_variable_core`\n\n#### Rule Macro\n\nAttach variable codelist and codelist terms\n"
        },
        {
          "const": "Domain Presence Check",
          "title": "Content domain presence at study level",
          "markdownDescription": "\n#### Columns\n\nSingle row contains a column for each domain and the value of that column is the domain's file name\n\n| AE     | EC     |\n| ------ | ------ |\n| ae.xpt | ec.xpt |\n\n#### Example\n\n```yaml\nall:\n  - name: PP\n    operator: exists\n  - name: PC\n    operator: not_exists\n```\n"
        },
        {
          "const": "Record Data",
          "title": "Content data at record level. Most common Rule Type",
          "markdownDescription": "\n#### Columns\n\nColumns are the columns within the original dataset\n\n#### Example\n\n```yaml\nall:\n  - name: --SCAT\n    operator: non_empty\n  - name: --SCAT\n    operator: equal_to\n    value: --CAT\n```\n"
        },
        {
          "const": "Value Check against Define XML Variable",
          "title": "Content data at value level and define xml metadata at variable level",
          "markdownDescription": "\n#### Columns\n\n- `row_number`\n- `variable_name`\n- `variable_value`\n- `define_variable_name`\n- `define_variable_label`\n- `define_variable_data_type`\n- `define_variable_`...\n\n#### Example\n\n```yaml\nall:\n  - name: define_variable_ccode\n    operator: empty\n  - name: variable_value\n    operator: non_empty\n  - name: define_variable_has_codelist\n    operator: equal_to\n    value: true\n  - name: variable_value\n    operator: is_not_contained_by\n    value: define_variable_codelist_coded_values`\n```\n"
        },
        {
          "const": "Value Check against Define XML VLM",
          "title": "Content data at value level and define xml metadata at value level",
          "markdownDescription": "\n#### Columns\n\n- `row_number`\n- `variable_name`\n- `variable_value`\n- `define_vlm_name`\n- `define_vlm_label`\n- `define_vlm_data_type`\n- `define_vlm_is_collected`\n- `define_vlm_role`\n- `define_vlm_size`\n- `define_vlm_ccode`\n- `define_vlm_format`\n- `define_vlm_allowed_terms`\n- `define_vlm_origin_type`\n- `define_vlm_has_no_data`\n- `define_vlm_order_number`\n- `define_vlm_length`\n- `define_vlm_has_codelist`\n- `define_vlm_codelist_coded_values`\n- `define_vlm_mandatory`\n- `define_variable_name`\n- `type_check`\n- `length_check`\n- `variable_value_length`\n\n#### Example\n\n```yaml\nall:\n  - name: define_vlm_ccode\n    operator: empty\n  - name: variable_value\n    operator: non_empty\n  - name: define_vlm_has_codelist\n    operator: equal_to\n    value: true\n  - name: variable_value\n    operator: is_not_contained_by\n    value: define_vlm_codelist_coded_values\n```\n\n```yaml\nall:\n  - name: variable_value\n    operator: empty\n  - name: define_vlm_mandatory\n    operator: equal_to\n    value: Yes\n```\n"
        },
        {
          "const": "Value Level Metadata Check against Define XML",
          "title": "Content data at record level and define xml metadata at value level",
          "markdownDescription": "\n#### Columns\n\nColumns are the columns within the original dataset\n\n#### Rule Macro\n\nAttach define xml metadata at value level\n"
        },
        {
          "const": "Variable Metadata Check",
          "title": "Content metadata at variable level",
          "markdownDescription": "\n#### Columns\n\n- `variable_name`\n- `variable_order_number`\n- `variable_label`\n- `variable_size`\n- `variable_data_type`\n- `variable_format`\n\n#### Example\n\n```yaml\n- name: variable_label\n  operator: longer_than\n  value: 40\n```\n"
        },
        {
          "const": "Variable Metadata Check against Define XML",
          "title": "Content metadata at variable level and define xml metadata at variable level",
          "markdownDescription": "\n#### Columns\n\n- `variable_name`\n- `variable_order_number`\n- `variable_label`\n- `variable_`...\n- `define_variable_name`\n- `define_variable_label`\n- `define_variable_`...\n\n#### Rule Macro\n\nAttach define xml metadata at variable level\n\n#### Example\n\n```yaml\n- name: variable_name\n  operator: not_equal_to\n  value: define_variable_name\n```\n"
        },
        {
          "const": "Variable Metadata Check against Library Metadata",
          "title": "Content metadata at the variable level and the corresponding library metadata",
          "markdownDescription": "\n#### Columns\n\n- `variable_name`\n- `variable_order_number`\n- `variable_label`\n- `variable_size`\n- `variable_data_type`\n- `variable_format`\n- `variable_has_empty_values`\n- `library_variable_name`\n- `library_variable_order_number`\n- `library_variable_label`\n- `library_variable_data_type`\n- `library_variable_role`\n- `library_variable_core`\n"
        },
        {
          "const": "Variable Metadata Check against Define XML and Library Metadata",
          "title": "Combines metadata at the variable level with corresponding define-xml metadata at variable level and corresponding library variable metadata"
        }
      ],
      "markdownDescription": "Determines how the primary dataset should be built before the rule is applied"
    },
    "Sensitivity.json": {
      "anyOf": [
        {
          "const": "Dataset",
          "markdownDescription": "\nReport one result per dataset generated by the `Rule Type`, where a dataset or record within the dataset matches the rule failure criteria\n"
        },
        {
          "const": "Record",
          "markdownDescription": "\nReport one result per record within the dataset generated by the `Rule Type`, where the record matches the rule failure criteria\n"
        }
      ],
      "markdownDescription": "Determines what level of granularity issues should be generated within the report"
    },
    "MetaVariables.json": {
      "anyOf": [
        {
          "const": "dataset_label",
          "markdownDescription": "\nLabel for the dataset\n"
        },
        {
          "const": "dataset_location",
          "markdownDescription": "\nPath to file\n"
        },
        {
          "const": "dataset_name",
          "markdownDescription": "\nName of the dataset\n"
        },
        {
          "const": "dataset_size",
          "markdownDescription": "\nFile size\n"
        },
        {
          "const": "define_dataset_class",
          "markdownDescription": "\nItemGroupDef.Class.Name\n"
        },
        {
          "const": "define_dataset_is_non_standard",
          "markdownDescription": "\nItemGroupDef.IsNonStandard\n"
        },
        {
          "const": "define_dataset_key_sequence",
          "markdownDescription": "\n[ItemGroupDef/ValueListDef].ItemRef.KeySequence\n"
        },
        {
          "const": "define_dataset_label",
          "markdownDescription": "\nItemGroupDef.Description.TranslatedText\n"
        },
        {
          "const": "define_dataset_location",
          "markdownDescription": "\nItemGroupDef.leaf.href\n"
        },
        {
          "const": "define_dataset_name",
          "markdownDescription": "\nItemGroupDef.Domain\n"
        },
        {
          "const": "define_dataset_structure",
          "markdownDescription": "\nItemGroupDef.Structure\n"
        },
        {
          "const": "define_variable_allowed_terms",
          "markdownDescription": "\nItemGroupDef.ItemDef.CodeList.CodeListItem.Decode.TranslatedText\n"
        },
        {
          "const": "define_variable_ccode",
          "markdownDescription": "\nItemGroupDef.ItemDef.CodeList.Alias.Name\n"
        },
        {
          "const": "define_variable_codelist_coded_values",
          "markdownDescription": "\nItemGroupDef.ItemDef.CodeList.[CodeListItem/EnumeratedItem].CodedValue\n"
        },
        {
          "const": "define_variable_data_type",
          "markdownDescription": "\nItemGroupDef.ItemDef.DataType\n"
        },
        {
          "const": "define_variable_format",
          "markdownDescription": "\n[Not Implemented]\n"
        },
        {
          "const": "define_variable_has_codelist",
          "markdownDescription": "\nItemGroupDef.ItemDef.CodeListRef exists\n"
        },
        {
          "const": "define_variable_has_comment",
          "markdownDescription": "\nItemGroupDef.ItemDef.CommentOID exists\n"
        },
        {
          "const": "define_variable_has_no_data",
          "markdownDescription": "\nItemGroupDef.ItemRef.HasNoData\n"
        },
        {
          "const": "define_variable_is_collected",
          "markdownDescription": "\nItemGroupDef.ItemDef.Origin.Type = \\\"Collected\\\" (2.1) or \\\"CRF\\\" (2.0)\n"
        },
        {
          "const": "define_variable_label",
          "markdownDescription": "\nItemGroupDef.ItemDef.Description.TranslatedText\n"
        },
        {
          "const": "define_variable_length",
          "markdownDescription": "\nItemGroupDef.ItemDef.Length\n"
        },
        {
          "const": "define_variable_mandatory",
          "markdownDescription": "\nItemGroupDef.ItemRef.Mandatory\n"
        },
        {
          "const": "define_variable_name",
          "markdownDescription": "\nItemGroupDef.ItemDef.Name\n"
        },
        {
          "const": "define_variable_order_number",
          "markdownDescription": "\nItemGroupDef.ItemRef.OrderNumber\n"
        },
        {
          "const": "define_variable_origin_type",
          "markdownDescription": "\nItemGroupDef.ItemDef.Origin.Type\n"
        },
        {
          "const": "define_variable_role",
          "markdownDescription": "\nItemGroupDef.ItemRef.Role\n"
        },
        {
          "const": "define_variable_size",
          "markdownDescription": "\nItemGroupDef.ItemDef.Size\n"
        },
        {
          "const": "define_vlm_allowed_terms",
          "markdownDescription": "\nValueListDef.ItemDef.CodeList.CodeListItem.Decode.TranslatedText\n"
        },
        {
          "const": "define_vlm_ccode",
          "markdownDescription": "\nValueListDef.ItemDef.CodeList.Alias.Name\n"
        },
        {
          "const": "define_vlm_codelist_coded_values",
          "markdownDescription": "\nValueListDef.ItemDef.CodeList.[CodeListItem/EnumeratedItem].CodedValue\n"
        },
        {
          "const": "define_vlm_data_type",
          "markdownDescription": "\nValueListDef.ItemDef.DataType\n"
        },
        {
          "const": "define_vlm_format",
          "markdownDescription": "\n[Not Implemented]\n"
        },
        {
          "const": "define_vlm_has_codelist",
          "markdownDescription": "\nValueListDef.ItemDef.CodeListRef exists\n"
        },
        {
          "const": "define_vlm_has_comment",
          "markdownDescription": "\nValueListDef.ItemDef.CommentOID exists\n"
        },
        {
          "const": "define_vlm_has_no_data",
          "markdownDescription": "\nValueListDef.ItemRef.HasNoData\n"
        },
        {
          "const": "define_vlm_is_collected",
          "markdownDescription": "\nValueListDef.ItemDef.Origin.Type = \\\"Collected\\\" (2.1) or \\\"CRF\\\" (2.0)\n"
        },
        {
          "const": "define_vlm_label",
          "markdownDescription": "\nValueListDef.ItemDef.Description.TranslatedText\n"
        },
        {
          "const": "define_vlm_length",
          "markdownDescription": "\nValueListDef.ItemDef.Length\n"
        },
        {
          "const": "define_vlm_mandatory",
          "markdownDescription": "\nValueListDef.ItemRef.Mandatory\n"
        },
        {
          "const": "define_vlm_name",
          "markdownDescription": "\nValueListDef.ItemDef.Name\n"
        },
        {
          "const": "define_vlm_order_number",
          "markdownDescription": "\nValueListDef.ItemRef.OrderNumber\n"
        },
        {
          "const": "define_vlm_origin_type",
          "markdownDescription": "\nValueListDef.ItemDef.Origin.Type\n"
        },
        {
          "const": "define_vlm_role",
          "markdownDescription": "\nValueListDef.ItemRef.Role\n"
        },
        {
          "const": "define_vlm_size",
          "markdownDescription": "\nValueListDef.ItemDef.Size\n"
        },
        {
          "const": "filename",
          "markdownDescription": "\nName of file\n"
        },
        {
          "const": "library_variable_core",
          "markdownDescription": "\ncore attribute of a variable from the CDISC Library\n"
        },
        {
          "const": "library_variable_data_type",
          "markdownDescription": "\nsimpleDatatype attribute of a variable from the CDISC Library\n"
        },
        {
          "const": "library_variable_label",
          "markdownDescription": "\nlabel attribute of a variable from the CDISC Library\n"
        },
        {
          "const": "library_variable_name",
          "markdownDescription": "\nname attribute of a variable from the CDISC Library\n"
        },
        {
          "const": "library_variable_order_number",
          "markdownDescription": "\nordinal attribute of a variable from the CDISC Library\n"
        },
        {
          "const": "library_variable_role",
          "markdownDescription": "\nrole attribute of a variable from the CDISC Library\n"
        },
        {
          "const": "row_number",
          "markdownDescription": "\n1-based index of record number\n"
        },
        {
          "const": "variable_data_type",
          "markdownDescription": "\nVariable data type (Char or Num)\n"
        },
        {
          "const": "variable_format",
          "markdownDescription": "\nVariable format\n"
        },
        {
          "const": "variable_has_empty_values",
          "markdownDescription": "\nTrue/False value indicating whether a variable has any empty values\n"
        },
        {
          "const": "variable_label",
          "markdownDescription": "\nVariable long label\n"
        },
        {
          "const": "variable_name",
          "markdownDescription": "\nVariable short name\n"
        },
        {
          "const": "variable_order_number",
          "markdownDescription": "\nOrder of variable within dataset\n"
        },
        {
          "const": "variable_size",
          "markdownDescription": "\nVariable size\n"
        },
        {
          "const": "variable_value",
          "markdownDescription": "\nValue at `row_number` and `variable_name`\n"
        },
        {
          "const": "variable_value_length",
          "markdownDescription": "\nCalculated length of the value at `row_number` and `variable_name`\n"
        }
      ]
    }
  },
  "$id": "https://cdisc.org/CORE-base.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "additionalProperties": false,
  "markdownDescription": "Validation schema CDISC Rules 1.0",
  "properties": {
    "Authorities": {
      "items": {
        "additionalProperties": false,
        "properties": {
          "Organization": {
            "type": "string"
          },
          "Standards": {
            "items": {
              "additionalProperties": false,
              "properties": {
                "Name": {
                  "type": "string"
                },
                "References": {
                  "items": {
                    "additionalProperties": false,
                    "properties": {
                      "Citations": {
                        "items": {
                          "additionalProperties": false,
                          "properties": {
                            "Cited Guidance": {
                              "type": "string"
                            },
                            "Document": {
                              "type": "string"
                            },
                            "Item": {
                              "type": "string"
                            },
                            "Section": {
                              "type": "string"
                            }
                          },
                          "required": [
                            "Document",
                            "Cited Guidance"
                          ],
                          "type": "object"
                        },
                        "type": "array"
                      },
                      "Criteria": {
                        "additionalProperties": false,
                        "anyOf": [
                          {
                            "required": [
                              "Logical Expression"
                            ]
                          },
                          {
                            "required": [
                              "Plain Language Expression"
                            ]
                          }
                        ],
                        "properties": {
                          "Logical Expression": {
                            "additionalProperties": false,
                            "properties": {
                              "Condition": {
                                "type": "string"
                              },
                              "Rule": {
                                "type": "string"
                              }
                            },
                            "required": [
                              "Rule"
                            ],
                            "type": "object"
                          },
                          "Plain Language Expression": {
                            "type": "string"
                          },
                          "Type": {
                            "enum": [
                              "Failure",
                              "Success"
                            ],
                            "type": "string"
                          }
                        },
                        "required": [
                          "Type"
                        ],
                        "type": "object"
                      },
                      "Origin": {
                        "type": "string"
                      },
                      "Related Rules": {
                        "items": {
                          "additionalProperties": false,
                          "properties": {
                            "Id": {
                              "type": "string"
                            },
                            "Relationship": {
                              "enum": [
                                "Predecessor",
                                "Related",
                                "Successor"
                              ],
                              "type": "string"
                            }
                          },
                          "required": [
                            "Id",
                            "Relationship"
                          ],
                          "type": "object"
                        },
                        "type": "array"
                      },
                      "Release Notes": {
                        "type": "string"
                      },
                      "Rule Identifier": {
                        "additionalProperties": false,
                        "properties": {
                          "Id": {
                            "type": "string"
                          },
                          "Version": {
                            "type": "string"
                          }
                        },
                        "required": [
                          "Id"
                        ],
                        "type": "object"
                      },
                      "Validator Rule Message": {
                        "type": "string"
                      },
                      "Version": {
                        "type": "string"
                      }
                    },
                    "required": [
                      "Origin",
                      "Rule Identifier",
                      "Version"
                    ],
                    "type": "object"
                  },
                  "minItems": 1,
                  "type": "array"
                },
                "Version": {
                  "type": "string"
                },
                "Substandard": {
                  "type": "string"
                }
              },
              "required": [
                "Name",
                "References",
                "Version"
              ],
              "type": "object"
            },
            "minItems": 1,
            "type": "array"
          }
        },
        "oneOf": [
          {
            "$ref": "#/$defs/Organization_CDISC.json"
          },
          {
            "$ref": "#/$defs/Organization_FDA.json"
          }
        ],
        "required": [
          "Organization",
          "Standards"
        ],
        "type": "object"
      },
      "minItems": 1,
      "type": "array"
    },
    "Check": {
      "$ref": "#/$defs/Boolean"
    },
    "Core": {
      "properties": {
        "Version": {
          "const": "1"
        }
      },
      "oneOf": [
        {
          "properties": {
            "Status": {
              "const": "Draft"
            }
          }
        },
        {
          "properties": {
            "Id": {
              "pattern": "^CORE-\\d{6}$",
              "type": "string"
            },
            "Status": {
              "const": "Published"
            }
          },
          "required": [
            "Id"
          ]
        }
      ],
      "required": [
        "Status",
        "Version"
      ],
      "type": "object"
    },
    "Description": {
      "type": "string"
    },
    "Executability": {
      "enum": [
        "Fully Executable",
        "Not Executable",
        "Partially Executable",
        "Partially Executable - Possible Overreporting",
        "Partially Executable - Possible Underreporting"
      ],
      "type": "string"
    },
    "Match Datasets": {
      "items": {
        "additionalProperties": false,
        "properties": {
          "Name": {
            "anyOf": [
              {
                "$ref": "#/$defs/Dataset"
              },
              {
                "$ref": "#/$defs/DataStructure"
              }
            ]
          },
          "Is Relationship": {
            "const": true
          },
          "Keys": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/$defs/VariableName"
                },
                {
                  "$ref": "#/$defs/LeftRightKeys"
                }
              ]
            },
            "type": "array"
          },
          "Join Type": {
            "$ref": "#/$defs/JoinType"
          },
          "Wildcard": {
            "type": "string"
          }
        },
        "required": [
          "Name"
        ],
        "type": "object"
      },
      "minItems": 1,
      "type": "array"
    },
    "Operations": {
      "items": {
        "$ref": "#/$defs/Operations.json"
      },
      "minItems": 1,
      "type": "array"
    },
    "Outcome": {
      "additionalProperties": false,
      "properties": {
        "Message": {
          "type": "string"
        },
        "Output Variables": {
          "items": {
            "$ref": "#/$defs/Operator.json/properties/name"
          },
          "type": "array"
        }
      },
      "required": [
        "Message"
      ],
      "type": "object"
    },
    "Rule Type": {
      "$ref": "#/$defs/Rule_Type.json"
    },
    "Scope": {
      "additionalProperties": false,
      "properties": {
        "Classes": {
          "anyOf": [
            {
              "additionalProperties": false,
              "properties": {
                "Include": {
                  "$ref": "#/$defs/Classes"
                }
              },
              "required": [
                "Include"
              ],
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "Exclude": {
                  "$ref": "#/$defs/Classes"
                }
              },
              "required": [
                "Exclude"
              ],
              "type": "object"
            }
          ]
        },
        "Data Structures": {
          "oneOf": [
            {
              "additionalProperties": false,
              "properties": {
                "Include": {
                  "$ref": "#/$defs/DataStructures"
                }
              },
              "required": [
                "Include"
              ],
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "Exclude": {
                  "$ref": "#/$defs/DataStructures"
                }
              },
              "required": [
                "Exclude"
              ],
              "type": "object"
            }
          ]
        },
        "Datasets": {
          "additionalProperties": false,
          "properties": {
            "Exclude": {
              "$ref": "#/$defs/Datasets"
            },
            "Include": {
              "$ref": "#/$defs/Datasets"
            }
          },
          "type": "object"
        },
        "Domains": {
          "$ref": "#/$defs/DomainStructure"
        },
        "Dataset or Domain or Item Group": {
          "$ref": "#/$defs/DomainStructure"
        },
        "Use Case": {
          "type": "string"
        },
        "Entities": {
          "anyOf": [
            {
              "additionalProperties": false,
              "properties": {
                "Exclude": {
                  "$ref": "#/$defs/PascalCases"
                },
                "Include": {
                  "$ref": "#/$defs/PascalCases"
                }
              },
              "anyOf": [
                {
                  "required": [
                    "Exclude"
                  ]
                },
                {
                  "required": [
                    "Include"
                  ]
                }
              ],
              "type": "object"
            }
          ]
        },
        "Subclasses": {
          "additionalProperties": false,
          "properties": {
            "Exclude": {
              "$ref": "#/$defs/Subclasses"
            },
            "Include": {
              "$ref": "#/$defs/Subclasses"
            }
          },
          "type": "object"
        }
      },
      "oneOf": [
        {
          "required": [
            "Classes",
            "Domains"
          ]
        },
        {
          "required": [
            "Data Structures"
          ]
        },
        {
          "required": [
            "Entities"
          ]
        }
      ],
      "type": "object"
    },
    "Sensitivity": {
      "$ref": "#/$defs/Sensitivity.json"
    }
  },
  "required": [
    "Authorities",
    "Check",
    "Core",
    "Description",
    "Outcome",
    "Executability",
    "Rule Type",
    "Scope",
    "Sensitivity"
  ],
  "type": "object"
}